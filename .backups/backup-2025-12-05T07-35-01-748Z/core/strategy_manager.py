# -*- coding: utf-8 -*-
"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager






"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager






"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager






"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager






"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager






"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager






"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager






"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager






"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager






"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager




"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager

"""
策略版本控制系统
专业的策略生命周期管理
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from enum import Enum
import json
import hashlib
import shutil
import logging

logger = logging.getLogger(__name__)


class StrategyStatus(Enum):
    """策略状态"""
    DRAFT = "draft"             # 草稿
    TESTING = "testing"         # 测试中
    BACKTESTED = "backtested"   # 已回测
    APPROVED = "approved"       # 已审核
    LIVE = "live"               # 实盘运行
    PAUSED = "paused"           # 暂停
    DEPRECATED = "deprecated"   # 已废弃


@dataclass
class StrategyVersion:
    """策略版本"""
    version: str                    # 版本号 (如 1.0.0)
    created_at: str                 # 创建时间
    author: str = ""                # 作者
    description: str = ""           # 版本描述
    code_hash: str = ""             # 代码哈希
    params: Dict = field(default_factory=dict)  # 参数快照
    backtest_results: Dict = field(default_factory=dict)  # 回测结果
    status: str = "draft"           # 状态
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyVersion':
        return cls(**data)


@dataclass
class StrategyMeta:
    """策略元数据"""
    name: str                       # 策略名称
    display_name: str = ""          # 显示名称
    description: str = ""           # 策略描述
    author: str = ""                # 作者
    created_at: str = ""            # 创建时间
    updated_at: str = ""            # 更新时间
    current_version: str = "1.0.0"  # 当前版本
    status: str = "draft"           # 状态
    tags: List[str] = field(default_factory=list)  # 标签
    versions: List[Dict] = field(default_factory=list)  # 版本历史
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'StrategyMeta':
        return cls(**data)


class StrategyVersionControl:
    """
    策略版本控制系统
    
    功能：
    - 版本管理：创建、切换、比较版本
    - 参数快照：保存和恢复策略参数
    - 回测记录：关联回测结果
    - 状态流转：管理策略生命周期
    """
    
    def __init__(self, strategies_dir: str = None):
        if strategies_dir is None:
            strategies_dir = Path(__file__).parent.parent / "strategies"
        
        self.strategies_dir = Path(strategies_dir)
        self.versions_dir = self.strategies_dir / ".versions"
        self.meta_file = self.strategies_dir / ".strategy_meta.json"
        
        # 确保目录存在
        self.versions_dir.mkdir(parents=True, exist_ok=True)
        
        # 加载元数据
        self._meta_cache: Dict[str, StrategyMeta] = {}
        self._load_meta()
    
    def _load_meta(self):
        """加载策略元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for name, meta_data in data.items():
                        self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            except Exception as e:
                logger.error(f"加载策略元数据失败: {e}")
    
    def _save_meta(self):
        """保存策略元数据"""
        try:
            data = {name: meta.to_dict() for name, meta in self._meta_cache.items()}
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"保存策略元数据失败: {e}")
    
    def _get_code_hash(self, code: str) -> str:
        """计算代码哈希"""
        return hashlib.md5(code.encode()).hexdigest()[:8]
    
    def _parse_version(self, version: str) -> tuple:
        """解析版本号"""
        parts = version.split('.')
        return tuple(int(p) for p in parts)
    
    def _increment_version(self, version: str, level: str = 'patch') -> str:
        """
        递增版本号
        
        Args:
            version: 当前版本
            level: 递增级别 (major, minor, patch)
        
        Returns:
            str: 新版本号
        """
        parts = list(self._parse_version(version))
        while len(parts) < 3:
            parts.append(0)
        
        if level == 'major':
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
        elif level == 'minor':
            parts[1] += 1
            parts[2] = 0
        else:  # patch
            parts[2] += 1
        
        return '.'.join(str(p) for p in parts)
    
    # ==================== 策略管理 ====================
    
    def register_strategy(
        self,
        name: str,
        display_name: str = "",
        description: str = "",
        author: str = "",
        tags: List[str] = None
    ) -> StrategyMeta:
        """
        注册新策略
        
        Args:
            name: 策略名称（唯一标识）
            display_name: 显示名称
            description: 策略描述
            author: 作者
            tags: 标签列表
        
        Returns:
            StrategyMeta: 策略元数据
        """
        if name in self._meta_cache:
            logger.warning(f"策略已存在: {name}")
            return self._meta_cache[name]
        
        now = datetime.now().isoformat()
        
        meta = StrategyMeta(
            name=name,
            display_name=display_name or name,
            description=description,
            author=author,
            created_at=now,
            updated_at=now,
            current_version="1.0.0",
            status="draft",
            tags=tags or [],
            versions=[]
        )
        
        self._meta_cache[name] = meta
        self._save_meta()
        
        logger.info(f"注册策略: {name}")
        return meta
    
    def get_strategy(self, name: str) -> Optional[StrategyMeta]:
        """获取策略元数据"""
        return self._meta_cache.get(name)
    
    def list_strategies(self, status: str = None, tag: str = None) -> List[StrategyMeta]:
        """
        列出策略
        
        Args:
            status: 状态过滤
            tag: 标签过滤
        
        Returns:
            List[StrategyMeta]: 策略列表
        """
        result = list(self._meta_cache.values())
        
        if status:
            result = [s for s in result if s.status == status]
        
        if tag:
            result = [s for s in result if tag in s.tags]
        
        return result
    
    def update_strategy_status(self, name: str, status: StrategyStatus) -> bool:
        """
        更新策略状态
        
        Args:
            name: 策略名称
            status: 新状态
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            logger.error(f"策略不存在: {name}")
            return False
        
        meta = self._meta_cache[name]
        meta.status = status.value
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"更新策略状态: {name} -> {status.value}")
        return True
    
    # ==================== 版本管理 ====================
    
    def create_version(
        self,
        name: str,
        code: str,
        description: str = "",
        params: Dict = None,
        level: str = 'patch'
    ) -> Optional[StrategyVersion]:
        """
        创建新版本
        
        Args:
            name: 策略名称
            code: 策略代码
            description: 版本描述
            params: 参数快照
            level: 版本递增级别
        
        Returns:
            StrategyVersion: 新版本
        """
        if name not in self._meta_cache:
            # 自动注册
            self.register_strategy(name)
        
        meta = self._meta_cache[name]
        
        # 计算新版本号
        new_version = self._increment_version(meta.current_version, level)
        
        # 创建版本对象
        version = StrategyVersion(
            version=new_version,
            created_at=datetime.now().isoformat(),
            author=meta.author,
            description=description,
            code_hash=self._get_code_hash(code),
            params=params or {},
            status="draft"
        )
        
        # 保存代码文件
        version_dir = self.versions_dir / name / new_version
        version_dir.mkdir(parents=True, exist_ok=True)
        
        code_file = version_dir / f"{name}.py"
        with open(code_file, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # 保存版本元数据
        meta_file = version_dir / "version.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(version.to_dict(), f, ensure_ascii=False, indent=2)
        
        # 更新策略元数据
        meta.versions.append(version.to_dict())
        meta.current_version = new_version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        
        logger.info(f"创建版本: {name} v{new_version}")
        return version
    
    def get_version(self, name: str, version: str = None) -> Optional[StrategyVersion]:
        """
        获取版本信息
        
        Args:
            name: 策略名称
            version: 版本号，默认当前版本
        
        Returns:
            StrategyVersion: 版本信息
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        for v in meta.versions:
            if v['version'] == version:
                return StrategyVersion.from_dict(v)
        
        return None
    
    def get_version_code(self, name: str, version: str = None) -> Optional[str]:
        """
        获取版本代码
        
        Args:
            name: 策略名称
            version: 版本号
        
        Returns:
            str: 策略代码
        """
        if name not in self._meta_cache:
            return None
        
        meta = self._meta_cache[name]
        version = version or meta.current_version
        
        code_file = self.versions_dir / name / version / f"{name}.py"
        
        if code_file.exists():
            with open(code_file, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def list_versions(self, name: str) -> List[StrategyVersion]:
        """列出所有版本"""
        if name not in self._meta_cache:
            return []
        
        meta = self._meta_cache[name]
        return [StrategyVersion.from_dict(v) for v in meta.versions]
    
    def switch_version(self, name: str, version: str) -> bool:
        """
        切换当前版本
        
        Args:
            name: 策略名称
            version: 目标版本
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 检查版本是否存在
        version_exists = any(v['version'] == version for v in meta.versions)
        if not version_exists:
            logger.error(f"版本不存在: {name} v{version}")
            return False
        
        meta.current_version = version
        meta.updated_at = datetime.now().isoformat()
        
        self._save_meta()
        logger.info(f"切换版本: {name} -> v{version}")
        return True
    
    def compare_versions(self, name: str, v1: str, v2: str) -> Dict:
        """
        比较两个版本
        
        Args:
            name: 策略名称
            v1: 版本1
            v2: 版本2
        
        Returns:
            Dict: 比较结果
        """
        code1 = self.get_version_code(name, v1)
        code2 = self.get_version_code(name, v2)
        
        ver1 = self.get_version(name, v1)
        ver2 = self.get_version(name, v2)
        
        return {
            'v1': v1,
            'v2': v2,
            'code_changed': code1 != code2,
            'params_v1': ver1.params if ver1 else {},
            'params_v2': ver2.params if ver2 else {},
            'backtest_v1': ver1.backtest_results if ver1 else {},
            'backtest_v2': ver2.backtest_results if ver2 else {},
        }
    
    # ==================== 回测结果管理 ====================
    
    def save_backtest_result(
        self,
        name: str,
        version: str,
        results: Dict
    ) -> bool:
        """
        保存回测结果
        
        Args:
            name: 策略名称
            version: 版本号
            results: 回测结果
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        meta = self._meta_cache[name]
        
        # 更新版本的回测结果
        for v in meta.versions:
            if v['version'] == version:
                v['backtest_results'] = results
                v['status'] = 'backtested'
                break
        
        meta.updated_at = datetime.now().isoformat()
        self._save_meta()
        
        # 保存详细结果到文件
        result_file = self.versions_dir / name / version / "backtest_result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2, default=str)
        
        logger.info(f"保存回测结果: {name} v{version}")
        return True
    
    def get_backtest_result(self, name: str, version: str = None) -> Optional[Dict]:
        """获取回测结果"""
        ver = self.get_version(name, version)
        if ver:
            return ver.backtest_results
        return None
    
    # ==================== 导出导入 ====================
    
    def export_strategy(self, name: str, output_path: str) -> bool:
        """
        导出策略（包含所有版本）
        
        Args:
            name: 策略名称
            output_path: 输出路径
        
        Returns:
            bool: 是否成功
        """
        if name not in self._meta_cache:
            return False
        
        try:
            output_dir = Path(output_path)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # 复制版本目录
            src_dir = self.versions_dir / name
            if src_dir.exists():
                shutil.copytree(src_dir, output_dir / name, dirs_exist_ok=True)
            
            # 导出元数据
            meta = self._meta_cache[name]
            meta_file = output_dir / f"{name}_meta.json"
            with open(meta_file, 'w', encoding='utf-8') as f:
                json.dump(meta.to_dict(), f, ensure_ascii=False, indent=2)
            
            logger.info(f"导出策略: {name} -> {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"导出策略失败: {e}")
            return False
    
    def import_strategy(self, input_path: str) -> Optional[str]:
        """
        导入策略
        
        Args:
            input_path: 输入路径
        
        Returns:
            str: 策略名称
        """
        try:
            input_dir = Path(input_path)
            
            # 查找元数据文件
            meta_files = list(input_dir.glob("*_meta.json"))
            if not meta_files:
                logger.error("未找到策略元数据文件")
                return None
            
            meta_file = meta_files[0]
            
            with open(meta_file, 'r', encoding='utf-8') as f:
                meta_data = json.load(f)
            
            name = meta_data['name']
            
            # 复制版本目录
            src_dir = input_dir / name
            if src_dir.exists():
                dst_dir = self.versions_dir / name
                shutil.copytree(src_dir, dst_dir, dirs_exist_ok=True)
            
            # 导入元数据
            self._meta_cache[name] = StrategyMeta.from_dict(meta_data)
            self._save_meta()
            
            logger.info(f"导入策略: {name}")
            return name
            
        except Exception as e:
            logger.error(f"导入策略失败: {e}")
            return None


# 全局实例
_strategy_manager = None


def get_strategy_manager() -> StrategyVersionControl:
    """获取策略版本控制实例"""
    global _strategy_manager
    if _strategy_manager is None:
        _strategy_manager = StrategyVersionControl()
    return _strategy_manager














