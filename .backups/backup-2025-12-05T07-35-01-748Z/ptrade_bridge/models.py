# -*- coding: utf-8 -*-
"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }






"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }






"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }






"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }






"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }






"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }






"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }






"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }






"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }






"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }




"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }

"""
PTrade Bridge - 标准数据模型
定义 Cursor ↔ PTrade Bridge ↔ PTrade 之间的数据结构
"""
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
from enum import Enum
import json


class StrategyStatus(str, Enum):
    """策略状态"""
    DRAFT = "draft"           # 草稿
    BACKTEST = "backtest"     # 回测中
    PAPER = "paper"           # 模拟交易
    LIVE = "live"             # 实盘交易
    STOPPED = "stopped"       # 已停止
    ERROR = "error"           # 异常


class OrderSide(str, Enum):
    """订单方向"""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Strategy:
    """策略模型"""
    id: str
    name: str
    version: str = "v1.0.0"
    status: StrategyStatus = StrategyStatus.DRAFT
    broker: str = "PTrade"
    description: str = ""
    code_path: str = ""
    parameters: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    updated_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "version": self.version,
            "status": self.status.value if isinstance(self.status, StrategyStatus) else self.status,
            "broker": self.broker,
            "description": self.description,
            "code_path": self.code_path,
            "parameters": self.parameters,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Strategy':
        status = data.get('status', 'draft')
        if isinstance(status, str):
            status = StrategyStatus(status)
        return cls(
            id=data['id'],
            name=data['name'],
            version=data.get('version', 'v1.0.0'),
            status=status,
            broker=data.get('broker', 'PTrade'),
            description=data.get('description', ''),
            code_path=data.get('code_path', ''),
            parameters=data.get('parameters', {}),
            created_at=data.get('created_at', ''),
            updated_at=data.get('updated_at', ''),
        )


@dataclass
class BacktestMetrics:
    """回测指标"""
    annual_return: float = 0.0
    total_return: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    win_rate: float = 0.0
    profit_loss_ratio: float = 0.0
    total_trades: int = 0
    volatility: float = 0.0
    alpha: float = 0.0
    beta: float = 0.0
    information_ratio: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class EquityPoint:
    """净值点"""
    date: str
    equity: float
    benchmark: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class BacktestResult:
    """回测结果"""
    id: str
    strategy_id: str
    strategy_name: str = ""
    start_date: str = ""
    end_date: str = ""
    initial_capital: float = 1000000
    final_capital: float = 1000000
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)
    equity_curve: List[EquityPoint] = field(default_factory=list)
    trades: List[Dict] = field(default_factory=list)
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if isinstance(self.metrics, dict):
            self.metrics = BacktestMetrics(**self.metrics)
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "strategy_name": self.strategy_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "initial_capital": self.initial_capital,
            "final_capital": self.final_capital,
            "metrics": self.metrics.to_dict() if isinstance(self.metrics, BacktestMetrics) else self.metrics,
            "equity_curve": [p.to_dict() if isinstance(p, EquityPoint) else p for p in self.equity_curve],
            "trades": self.trades,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'BacktestResult':
        metrics = data.get('metrics', {})
        if isinstance(metrics, dict):
            metrics = BacktestMetrics(**metrics)
        
        equity_curve = []
        for p in data.get('equity_curve', []):
            if isinstance(p, dict):
                equity_curve.append(EquityPoint(**p))
            else:
                equity_curve.append(p)
        
        return cls(
            id=data['id'],
            strategy_id=data['strategy_id'],
            strategy_name=data.get('strategy_name', ''),
            start_date=data.get('start_date', ''),
            end_date=data.get('end_date', ''),
            initial_capital=data.get('initial_capital', 1000000),
            final_capital=data.get('final_capital', 1000000),
            metrics=metrics,
            equity_curve=equity_curve,
            trades=data.get('trades', []),
            created_at=data.get('created_at', ''),
        )


@dataclass
class Order:
    """订单"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    volume: int
    price: float
    order_type: str = "LIMIT"
    status: OrderStatus = OrderStatus.PENDING
    filled_volume: int = 0
    filled_price: float = 0.0
    create_time: str = ""
    update_time: str = ""
    account_id: str = ""
    
    def __post_init__(self):
        if not self.create_time:
            self.create_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if isinstance(self.status, str):
            self.status = OrderStatus(self.status)
    
    def to_dict(self) -> Dict:
        return {
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "order_type": self.order_type,
            "status": self.status.value,
            "filled_volume": self.filled_volume,
            "filled_price": self.filled_price,
            "create_time": self.create_time,
            "update_time": self.update_time,
            "account_id": self.account_id,
        }


@dataclass
class Trade:
    """成交记录"""
    trade_id: str
    order_id: str
    strategy_id: str
    symbol: str
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    volume: int = 0
    price: float = 0.0
    amount: float = 0.0
    commission: float = 0.0
    trade_time: str = ""
    account_id: str = ""
    pnl: float = 0.0
    
    def __post_init__(self):
        if not self.trade_time:
            self.trade_time = datetime.now().isoformat()
        if isinstance(self.side, str):
            self.side = OrderSide(self.side)
        if self.amount == 0 and self.volume > 0 and self.price > 0:
            self.amount = self.volume * self.price
    
    def to_dict(self) -> Dict:
        return {
            "trade_id": self.trade_id,
            "order_id": self.order_id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "symbol_name": self.symbol_name,
            "side": self.side.value,
            "volume": self.volume,
            "price": self.price,
            "amount": self.amount,
            "commission": self.commission,
            "trade_time": self.trade_time,
            "account_id": self.account_id,
            "pnl": self.pnl,
        }


@dataclass
class Position:
    """持仓"""
    symbol: str
    symbol_name: str = ""
    volume: int = 0
    available: int = 0
    cost_price: float = 0.0
    current_price: float = 0.0
    market_value: float = 0.0
    profit: float = 0.0
    profit_rate: float = 0.0
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Account:
    """账户信息"""
    account_id: str
    total_asset: float = 0.0
    cash: float = 0.0
    market_value: float = 0.0
    frozen_cash: float = 0.0
    available_cash: float = 0.0
    total_profit: float = 0.0
    daily_profit: float = 0.0
    positions: List[Position] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "account_id": self.account_id,
            "total_asset": self.total_asset,
            "cash": self.cash,
            "market_value": self.market_value,
            "frozen_cash": self.frozen_cash,
            "available_cash": self.available_cash,
            "total_profit": self.total_profit,
            "daily_profit": self.daily_profit,
            "positions": [p.to_dict() if isinstance(p, Position) else p for p in self.positions],
        }














