# -*- coding: utf-8 -*-
"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")






"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")






"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")






"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")






"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")






"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")






"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")






"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")






"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")






"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")




"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")

"""
PTrade Bridge - 核心服务
负责策略管理、数据读取、PTrade对接
"""
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import json
import os
import logging
import shutil
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from .models import (
    Strategy, StrategyStatus, BacktestResult, BacktestMetrics,
    Trade, Order, Account, Position, EquityPoint
)

logger = logging.getLogger(__name__)


class PTradeBridgeConfig:
    """PTrade Bridge 配置"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or str(
            Path(__file__).parent.parent / "config" / "ptrade_bridge_config.json"
        )
        
        # 默认配置
        self.strategies_dir = str(Path(__file__).parent.parent / "strategies" / "ptrade")
        self.data_dir = str(Path(__file__).parent.parent / "data" / "ptrade")
        self.backtest_results_dir = str(Path(self.data_dir) / "backtest_results")
        self.trade_records_dir = str(Path(self.data_dir) / "trade_records")
        self.positions_dir = str(Path(self.data_dir) / "positions")
        
        # PTrade 配置（文件导出路径）
        self.ptrade_export_dir = ""  # PTrade 导出报告的目录
        self.ptrade_strategies_dir = ""  # PTrade 策略目录
        
        # 服务配置
        self.host = "127.0.0.1"
        self.port = 8000
        self.auto_sync = True
        self.sync_interval = 60  # 秒
        
        self._load_config()
        self._ensure_dirs()
    
    def _load_config(self):
        """加载配置文件"""
        if Path(self.config_path).exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self, key):
                            setattr(self, key, value)
                logger.info(f"配置加载成功: {self.config_path}")
            except Exception as e:
                logger.warning(f"配置加载失败: {e}")
    
    def _ensure_dirs(self):
        """确保目录存在"""
        for dir_path in [
            self.strategies_dir,
            self.data_dir,
            self.backtest_results_dir,
            self.trade_records_dir,
            self.positions_dir,
        ]:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        """保存配置"""
        data = {
            "strategies_dir": self.strategies_dir,
            "data_dir": self.data_dir,
            "backtest_results_dir": self.backtest_results_dir,
            "trade_records_dir": self.trade_records_dir,
            "positions_dir": self.positions_dir,
            "ptrade_export_dir": self.ptrade_export_dir,
            "ptrade_strategies_dir": self.ptrade_strategies_dir,
            "host": self.host,
            "port": self.port,
            "auto_sync": self.auto_sync,
            "sync_interval": self.sync_interval,
        }
        
        Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


class PTradeFileHandler(FileSystemEventHandler):
    """PTrade 文件变化监听器"""
    
    def __init__(self, service: 'PTradeBridgeService'):
        self.service = service
    
    def on_created(self, event):
        if not event.is_directory:
            logger.info(f"检测到新文件: {event.src_path}")
            self.service.on_file_changed(event.src_path)
    
    def on_modified(self, event):
        if not event.is_directory:
            logger.info(f"检测到文件修改: {event.src_path}")
            self.service.on_file_changed(event.src_path)


class PTradeBridgeService:
    """
    PTrade Bridge 核心服务
    
    功能:
    - 策略管理 (CRUD)
    - 回测结果读取与解析
    - 交易记录同步
    - 文件监听自动同步
    """
    
    def __init__(self, config: PTradeBridgeConfig = None):
        self.config = config or PTradeBridgeConfig()
        
        # 内存缓存
        self._strategies: Dict[str, Strategy] = {}
        self._backtests: Dict[str, BacktestResult] = {}
        self._trades: Dict[str, List[Trade]] = {}  # strategy_id -> trades
        
        # 文件监听
        self._observer: Optional[Observer] = None
        
        # 初始化加载
        self._load_all_data()
    
    # ==================== 策略管理 ====================
    
    def get_strategies(self) -> List[Strategy]:
        """获取所有策略"""
        return list(self._strategies.values())
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """获取单个策略"""
        return self._strategies.get(strategy_id)
    
    def create_strategy(self, strategy: Strategy) -> Strategy:
        """创建策略"""
        strategy.created_at = datetime.now().isoformat()
        strategy.updated_at = strategy.created_at
        
        self._strategies[strategy.id] = strategy
        self._save_strategy_meta(strategy)
        
        logger.info(f"创建策略: {strategy.id} - {strategy.name}")
        return strategy
    
    def update_strategy(self, strategy_id: str, updates: Dict) -> Optional[Strategy]:
        """更新策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return None
        
        for key, value in updates.items():
            if hasattr(strategy, key):
                setattr(strategy, key, value)
        
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"更新策略: {strategy_id}")
        return strategy
    
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            
            # 删除元数据文件
            meta_file = Path(self.config.strategies_dir) / f"{strategy_id}_meta.json"
            if meta_file.exists():
                meta_file.unlink()
            
            logger.info(f"删除策略: {strategy_id}")
            return True
        return False
    
    def deploy_strategy(self, strategy_id: str) -> Dict:
        """
        部署策略到 PTrade
        
        将策略代码复制到 PTrade 策略目录
        """
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        if not strategy.code_path or not Path(strategy.code_path).exists():
            return {"success": False, "message": "策略代码文件不存在"}
        
        if not self.config.ptrade_strategies_dir:
            return {"success": False, "message": "未配置 PTrade 策略目录"}
        
        try:
            # 复制策略文件到 PTrade 目录
            dest_path = Path(self.config.ptrade_strategies_dir) / Path(strategy.code_path).name
            shutil.copy2(strategy.code_path, dest_path)
            
            # 更新策略状态
            strategy.status = StrategyStatus.BACKTEST
            strategy.updated_at = datetime.now().isoformat()
            self._save_strategy_meta(strategy)
            
            logger.info(f"策略已部署: {strategy_id} -> {dest_path}")
            return {
                "success": True, 
                "message": f"策略已部署到 {dest_path}",
                "deployed_path": str(dest_path)
            }
        except Exception as e:
            logger.error(f"部署策略失败: {e}")
            return {"success": False, "message": str(e)}
    
    def stop_strategy(self, strategy_id: str) -> Dict:
        """停止策略"""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            return {"success": False, "message": "策略不存在"}
        
        strategy.status = StrategyStatus.STOPPED
        strategy.updated_at = datetime.now().isoformat()
        self._save_strategy_meta(strategy)
        
        logger.info(f"策略已停止: {strategy_id}")
        return {"success": True, "message": "策略已停止"}
    
    # ==================== 回测结果 ====================
    
    def get_backtests(self, strategy_id: str = None) -> List[BacktestResult]:
        """获取回测结果"""
        if strategy_id:
            return [bt for bt in self._backtests.values() if bt.strategy_id == strategy_id]
        return list(self._backtests.values())
    
    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        """获取单个回测结果"""
        return self._backtests.get(backtest_id)
    
    def get_latest_backtest(self, strategy_id: str) -> Optional[BacktestResult]:
        """获取策略最新回测结果"""
        backtests = self.get_backtests(strategy_id)
        if backtests:
            return max(backtests, key=lambda x: x.created_at)
        return None
    
    # ==================== 交易记录 ====================
    
    def get_trades(self, strategy_id: str = None, limit: int = 100) -> List[Trade]:
        """获取交易记录"""
        if strategy_id:
            trades = self._trades.get(strategy_id, [])
        else:
            trades = []
            for t_list in self._trades.values():
                trades.extend(t_list)
        
        # 按时间倒序
        trades.sort(key=lambda x: x.trade_time, reverse=True)
        return trades[:limit]
    
    # ==================== 数据加载 ====================
    
    def _load_all_data(self):
        """加载所有数据"""
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
    
    def _load_strategies(self):
        """加载策略"""
        strategies_dir = Path(self.config.strategies_dir)
        
        # 从 meta 文件加载
        for meta_file in strategies_dir.glob("*_meta.json"):
            try:
                with open(meta_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    strategy = Strategy.from_dict(data)
                    self._strategies[strategy.id] = strategy
            except Exception as e:
                logger.warning(f"加载策略元数据失败 {meta_file}: {e}")
        
        # 扫描策略代码文件，自动创建未注册的策略
        for py_file in strategies_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue
            
            strategy_id = py_file.stem
            if strategy_id not in self._strategies and not strategy_id.endswith("_meta"):
                # 自动创建策略记录
                strategy = Strategy(
                    id=strategy_id,
                    name=strategy_id.replace("_", " ").title(),
                    code_path=str(py_file),
                )
                self._strategies[strategy_id] = strategy
                self._save_strategy_meta(strategy)
        
        logger.info(f"加载了 {len(self._strategies)} 个策略")
    
    def _load_backtests(self):
        """加载回测结果"""
        results_dir = Path(self.config.backtest_results_dir)
        
        for result_file in results_dir.glob("*.json"):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 转换为标准格式
                backtest = self._parse_backtest_result(data, result_file.stem)
                if backtest:
                    self._backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning(f"加载回测结果失败 {result_file}: {e}")
        
        logger.info(f"加载了 {len(self._backtests)} 个回测结果")
    
    def _load_trades(self):
        """加载交易记录"""
        trades_dir = Path(self.config.trade_records_dir)
        
        for trade_file in trades_dir.glob("*.json"):
            try:
                with open(trade_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                strategy_id = trade_file.stem.replace("_trades", "")
                
                trades = []
                for t in data if isinstance(data, list) else data.get('trades', []):
                    trade = Trade(
                        trade_id=t.get('trade_id', ''),
                        order_id=t.get('order_id', ''),
                        strategy_id=strategy_id,
                        symbol=t.get('symbol', t.get('stock', '')),
                        symbol_name=t.get('symbol_name', t.get('stock_name', '')),
                        side=t.get('side', t.get('action', 'BUY')),
                        volume=t.get('volume', t.get('quantity', 0)),
                        price=t.get('price', 0),
                        amount=t.get('amount', 0),
                        trade_time=t.get('trade_time', t.get('date', '')),
                        pnl=t.get('pnl', 0),
                    )
                    trades.append(trade)
                
                self._trades[strategy_id] = trades
            except Exception as e:
                logger.warning(f"加载交易记录失败 {trade_file}: {e}")
        
        logger.info(f"加载了 {sum(len(t) for t in self._trades.values())} 条交易记录")
    
    def _parse_backtest_result(self, data: Dict, default_id: str) -> Optional[BacktestResult]:
        """解析回测结果（兼容多种格式）"""
        try:
            # 提取基本信息
            backtest_id = data.get('id', f"bt_{default_id}")
            strategy_id = data.get('strategy_id', default_id.replace('_result', ''))
            strategy_name = data.get('strategy_name', strategy_id)
            
            # 提取指标
            metrics_data = data.get('metrics', data)
            metrics = BacktestMetrics(
                annual_return=metrics_data.get('annual_return', 0),
                total_return=metrics_data.get('total_return', 0),
                max_drawdown=abs(metrics_data.get('max_drawdown', 0)),
                sharpe_ratio=metrics_data.get('sharpe_ratio', metrics_data.get('sharpe', 0)),
                sortino_ratio=metrics_data.get('sortino_ratio', 0),
                calmar_ratio=metrics_data.get('calmar_ratio', 0),
                win_rate=metrics_data.get('win_rate', 0),
                profit_loss_ratio=metrics_data.get('profit_loss_ratio', 0),
                total_trades=metrics_data.get('total_trades', 0),
                volatility=metrics_data.get('volatility', 0),
                alpha=metrics_data.get('alpha', 0),
                beta=metrics_data.get('beta', 0),
            )
            
            # 提取净值曲线
            equity_curve = []
            for point in data.get('equity_curve', data.get('daily_returns', [])):
                if isinstance(point, dict):
                    equity_curve.append(EquityPoint(
                        date=point.get('date', ''),
                        equity=point.get('equity', point.get('nav', 1) * data.get('initial_capital', 1000000)),
                        benchmark=point.get('benchmark', 0),
                    ))
            
            return BacktestResult(
                id=backtest_id,
                strategy_id=strategy_id,
                strategy_name=strategy_name,
                start_date=data.get('start_date', ''),
                end_date=data.get('end_date', ''),
                initial_capital=data.get('initial_capital', 1000000),
                final_capital=data.get('final_capital', 1000000),
                metrics=metrics,
                equity_curve=equity_curve,
                trades=data.get('trades', []),
            )
        except Exception as e:
            logger.error(f"解析回测结果失败: {e}")
            return None
    
    def _save_strategy_meta(self, strategy: Strategy):
        """保存策略元数据"""
        meta_file = Path(self.config.strategies_dir) / f"{strategy.id}_meta.json"
        with open(meta_file, 'w', encoding='utf-8') as f:
            json.dump(strategy.to_dict(), f, ensure_ascii=False, indent=2)
    
    # ==================== 文件监听 ====================
    
    def on_file_changed(self, file_path: str):
        """文件变化回调"""
        path = Path(file_path)
        
        if path.suffix == '.json':
            if 'backtest' in path.name.lower() or 'result' in path.name.lower():
                # 重新加载回测结果
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    backtest = self._parse_backtest_result(data, path.stem)
                    if backtest:
                        self._backtests[backtest.id] = backtest
                        logger.info(f"回测结果已更新: {backtest.id}")
                except Exception as e:
                    logger.error(f"解析回测结果失败: {e}")
            
            elif 'trade' in path.name.lower():
                # 重新加载交易记录
                self._load_trades()
    
    def start_watching(self):
        """启动文件监听"""
        if self._observer:
            return
        
        self._observer = Observer()
        handler = PTradeFileHandler(self)
        
        # 监听数据目录
        self._observer.schedule(handler, self.config.data_dir, recursive=True)
        
        # 如果配置了 PTrade 导出目录，也监听
        if self.config.ptrade_export_dir and Path(self.config.ptrade_export_dir).exists():
            self._observer.schedule(handler, self.config.ptrade_export_dir, recursive=True)
        
        self._observer.start()
        logger.info("文件监听已启动")
    
    def stop_watching(self):
        """停止文件监听"""
        if self._observer:
            self._observer.stop()
            self._observer.join()
            self._observer = None
            logger.info("文件监听已停止")
    
    # ==================== 数据刷新 ====================
    
    def refresh(self):
        """刷新所有数据"""
        self._strategies.clear()
        self._backtests.clear()
        self._trades.clear()
        self._load_all_data()
        logger.info("数据已刷新")














